<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Tic-Tac-Toe</title>
    <style>
        /* General Styles */
        body, html {
            height: 100%;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* background-color: #1e1e1e; */
            background: radial-gradient(circle, rgba(13,13,38,1) 0%, rgba(39,29,98,1) 35%, rgba(0,0,0,1) 100%);
            color: #ffffff;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            text-align: center;
            max-width: 600px;
            width: 90%;
            padding: 20px;
            background-color: #2c2c2c;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
        }

        h1 {
            margin-bottom: 10px;
            color: #61dafb;
            text-shadow: 2px 2px #000;
        }

        #gameStatus {
            margin-bottom: 20px;
            font-size: 1.5em;
            min-height: 1.5em;
        }

        /* Game Board Styles */
        #boardContainer {
            position: relative;
            width: 320px;
            height: 320px;
            margin: 0 auto;
        }

        #entanglements {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 320px;
            pointer-events: none;
            z-index: 2; /* Bring lines above the grid */
        }

        #board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            grid-template-rows: repeat(3, 100px);
            gap: 5px;
            position: relative;
            z-index: 1;
        }

        .cell {
            background-color: #3e444e;
            border: 2px solid #61dafb;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            cursor: pointer;
            position: relative;
            transition: background-color 0.3s, transform 0.3s;
            overflow: hidden;
            border-radius: 5px;
        }

        .cell:hover {
            background-color: #4a5363;
        }

        .cell.occupied {
            cursor: not-allowed;
            transition: transform 0.3s;
        }

        .cell.X {
            color: #e63946;
            animation: fadeIn 0.5s ease-in-out;
        }

        .cell.O {
            color: #1d3557;
            animation: fadeIn 0.5s ease-in-out;
        }

        /* Quantum State Animation */
        .cell.quantum {
            background: linear-gradient(45deg, #555, #777, #555);
            background-size: 400% 400%;
            animation: quantumPulse 0.25s ease infinite;
            position: relative;
        }

        .cell.quantum::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: transparent;
            pointer-events: none;
        }

        @keyframes quantumPulse {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Entanglement Indicators */
        .entanglement {
            position: absolute;
            bottom: 4px;
            left: 4px;
            background-color: rgba(255, 255, 255, 0.8);
            color: #000;
            padding: 2px 4px;
            border-radius: 4px;
            font-size: 0.7em;
            z-index: 3; /* Ensure indicators are above lines */
        }

        /* Controls Styles */
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #61dafb;
            color: #000;
            transition: background-color 0.3s, transform 0.2s;
            /* box-shadow: 0 4px #3e8e41; */
        }

        button:hover {
            background-color: #21a1f1;
            transform: scale(1.05);
        }

        button:active {
            background-color: #21a1f1;
            box-shadow: 0 2px #8846f9;
            transform: translateY(2px);
        }

        button:disabled {
            background-color: #888;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Message Styles */
        #message {
            margin-top: 20px;
            font-size: 1.4em; /* Increased font size */
            min-height: 1.4em;
            padding: 10px; /* Added padding */
            background-color: #444; /* Subtle background color */
            border-radius: 5px; /* Rounded corners */
            box-shadow: 0px 0px 10px #61dafb; /* Subtle glow effect */
            transition: all 0.3s ease-in-out; /* Smooth transition */
        }

        /* SVG Entanglement Lines */
        #entanglements svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 320px;
            pointer-events: none;
            z-index: 2; /* Above the grid */
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.5); }
            to { opacity: 1; transform: scale(1); }
        }

        @keyframes lineDraw {
            from { stroke-dashoffset: 1000; }
            to { stroke-dashoffset: 0; }
        }

        /* Highlight for Reversals */
        .highlight {
            animation: highlightFlash 0.5s ease-in-out;
        }

        @keyframes highlightFlash {
            0% { box-shadow: 0 0 10px 5px yellow; }
            100% { box-shadow: none; }
        }

        /* Curved Lines Styles */
        .entanglement-line {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: lineDraw 1.5s forwards;
            filter: url(#glow);
        }

        /* Define glow effect */
        svg defs {
            filter: url(#glow);
        }

        /* Responsive Design */
        @media (max-width: 400px) {
            #boardContainer {
                width: 280px;
                height: 280px;
            }

            #board {
                grid-template-columns: repeat(3, 80px);
                grid-template-rows: repeat(3, 80px);
                gap: 5px;
            }

            .cell {
                font-size: 2.5em;
            }

            #entanglements {
                width: 280px;
                height: 280px;
            }
        }

        /* Modal Styles */
        .rules-modal {
            display: flex; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 10; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            /* background-color: rgba(0,0,0,0.7); Black w/ opacity */
            background: radial-gradient(circle, rgba(13,13,38,1) 0%, rgba(39,29,98,1) 35%, rgba(0,0,0,1) 100%);
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }

        .sound-modal {
            display: flex; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 10; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            /* background-color: rgba(0,0,0,0.7); Black w/ opacity */
            background: radial-gradient(circle, rgba(13,13,38,1) 0%, rgba(39,29,98,1) 35%, rgba(0,0,0,1) 100%);
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
        }


        .rules-modal-content {
            background-color: #2c2c2c;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 10px;
            color: #fff;
            position: relative;
        }

        .sound-modal-content {
            background-color: #2c2c2c;
            margin: 10% auto; /* 10% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 10px;
            color: #fff;
            position: relative;
            text-align: center; /* Center text and inline content */
            display: flex; /* Enable flexbox layout */
            justify-content: center; /* Center children horizontally */
            align-items: center; /* Center children vertically */
            flex-direction: column; /* Stack children vertically */
        }

        .close {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 25px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover,
        .close:focus {
            color: #fff;
            text-decoration: none;
        }

        /* Rules Button */
        #rulesButton {
            background-color: #ffcc00;
            color: #000;
        }

        #rulesButton:hover {
            background-color: #e6b800;
        }

        button#playInitialMusicButton {
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
        }
        button#playInitialMusicButton img {
            width: 50px;
            height: auto;
        }
        #playMusicButton {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 20; /* Make sure it's above other content */
            display: none; /* Start hidden and show after sound is enabled */
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
        }

        #playMusicButton img {
            width: 30px; /* Smaller icon after the modal is closed */
            height: auto;
        }
    </style>
</head>
<body>
    <audio id="backgroundMusic" loop>
        <source src="audio.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>

    <div id="gameContainer">
        <h1>Quantum Tic-Tac-Toe</h1>
        <div id="gameStatus">Player X's Turn</div>
        <div id="boardContainer">
            <svg id="entanglements">
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            </svg>
            <div id="board">
                <!-- 9 cells -->
                <div class="cell quantum" data-index="0"></div>
                <div class="cell quantum" data-index="1"></div>
                <div class="cell quantum" data-index="2"></div>
                <div class="cell quantum" data-index="3"></div>
                <div class="cell quantum" data-index="4"></div>
                <div class="cell quantum" data-index="5"></div>
                <div class="cell quantum" data-index="6"></div>
                <div class="cell quantum" data-index="7"></div>
                <div class="cell quantum" data-index="8"></div>
            </div>
        </div>
        <div id="controls">
            <button id="classicalMove">Classical Move</button>
            <button id="quantumMove">Quantum Move</button>
            <button id="reset">Reset Game</button>
            <button id="rulesButton">Rules</button>
        </div>
        <div id="message"></div>
    </div>

    <!-- Modal for Rules -->
    <div id="rulesModal" class="rules-modal">
        <div class="rules-modal-content">
            <span class="close">&times;</span>
            <h2>Welcome to Quantum Tic-Tac-Toe, wizard!</h2>
            <p>
                Unlike the Muggle Tic-tac-toe, here each box is hidden from you. They start in a state of both X and O, a <strong>SUPERPOSITION</strong> of states. This state will collapse into either X or O (a <strong>CLASSICAL</strong> state) when you decide to look into the box.
            </p>
            <p>
                But, that's not it. It is not all luck. Your outcome is in your hands. Wave your wand and entangle your boxes with each other, so you can affect boxes that you did not even look into ... boxes far, far, away from you.
            </p>
            <p>
                But beware! It may go against you as well.
            </p>
            <p>
                <strong>Moves:</strong>
                <ol>
                    <li><strong>Classical Move:</strong> Collapse a quantum state to either 'X' or 'O' with equal probability.</li>
                    <li><strong>Quantum Move:</strong> Entangle a control box (quantum state) with a target box (classical state). If the control box collapses to the player's favored state, the target box state "reverses" (strategize here!).</li>
                </ol>
            </p>
            <p>
                <strong>Player Favored States:</strong>
                <ul>
                    <li><strong>Player X:</strong> Favored state is 'X'.</li>
                    <li><strong>Player O:</strong> Favored state is 'O'.</li>
                </ul>
            </p>
            <p>
                <strong>Winning Condition:</strong> Align three of your marks ('X' or 'O') in a row, column, or diagonal.
            </p>
            <p>
                <strong>Game Start:</strong> Player X begins with a classical move.
            </p>
            <p>
                Strategize your moves considering entanglements that can affect future state collapses.
            </p>
            <h2>Challenge. Strategize. Win!</h2>
        </div>
    </div>

    <!-- Modal for Sound -->
    <div id="soundPromptModal" class="sound-modal">
        <div class="sound-modal-content">
            <h2>Enable sound to enjoy the best user experience.</p>
            <button id="playInitialMusicButton">
                <img src="loudspeaker_strike.png" alt="Play Music">
            </button>
        </div>
    </div>

    <button id="playMusicButton" style="display: none;">
        <img src="loudspeaker_strike.png" alt="Play Music" id="playIcon" style="display: none">
        <img src="loudspeaker.png" alt="Pause Music" id="pauseIcon" style="display: block">
    </button>

    <script>
        // Game States
        const EMPTY = null;
        const PLAYER_X = 'X';
        const PLAYER_O = 'O';

        // Quantum States
        const Q_ZERO = '0';
        const Q_ONE = '1';

        // Initialize Game Variables
        let board = Array(9).fill(EMPTY).map(() => ({
            state: 'quantum',    // 'quantum' or 'classical'
            value: EMPTY,        // 'X', 'O', or EMPTY
            entangledWith: null  // Index of entangled control box
        }));
        let currentPlayer = PLAYER_X;
        let selectedMove = null; // For quantum moves
        let message = '';
        let addedEventListener = null;

        // DOM Elements
        const cells = document.querySelectorAll('.cell');
        const gameStatus = document.getElementById('gameStatus');
        const classicalButton = document.getElementById('classicalMove');
        const quantumButton = document.getElementById('quantumMove');
        const resetButton = document.getElementById('reset');
        const rulesButton = document.getElementById('rulesButton');
        const musicToggle = document.getElementById('playMusicButton');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const messageDiv = document.getElementById('message');
        const entanglementsSVG = document.getElementById('entanglements');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');

        // Modal Elements
        const rulesModal = document.getElementById("rulesModal");
        const span = document.getElementsByClassName("close")[0];
        const soundModal = document.getElementById('soundPromptModal');
        const initialMusicButton = document.getElementById('playInitialMusicButton');

        // Render Function
        function render() {
            cells.forEach((cell, index) => {
                const cellData = board[index];
                cell.classList.remove('occupied', 'X', 'O', 'highlight', 'quantum');
                cell.style.backgroundColor = '#3e444e';
                cell.innerHTML = '';

                if (cellData.state === 'classical') {
                    cell.classList.add('occupied');
                    cell.classList.add(cellData.value);
                    cell.textContent = cellData.value;
                    // Apply color based on player
                    cell.style.backgroundColor = '#ffffff'
                } else {
                    // Quantum state animation
                    cell.classList.add('quantum');
                }

                // Show entanglement if any
                // if (cellData.entangledWith !== null) {
                //     const entDiv = document.createElement('div');
                //     entDiv.classList.add('entanglement');
                //     entDiv.textContent = `E:${cellData.entangledWith +1}`;
                //     entDiv.style.fontSize = 1;
                //     cell.appendChild(entDiv);
                // }
            });

            // Clear and redraw entanglement lines
            drawEntanglements();

            gameStatus.textContent = `Player ${currentPlayer}'s Turn`;
            messageDiv.textContent = message;
        }

        // Draw Entanglements using SVG Paths with Curves
        function drawEntanglements() {
            // Clear existing lines
            const existingLines = entanglementsSVG.querySelectorAll('.entanglement-line');
            existingLines.forEach(line => line.remove());

            board.forEach((cell, index) => {
                if (cell.entangledWith !== null) {
                    const controlIndex = cell.entangledWith;
                    drawCurvedLine(controlIndex, index, cell.value);
                }
            });
        }

        // Function to draw a curved line between two cells
        function drawCurvedLine(fromIndex, toIndex, player) {
            const cellSize = 100;
            const gap = 5;
            const svgSize = entanglementsSVG.clientWidth;

            // Calculate positions (center of cells)
            const getPosition = (idx) => {
                const row = Math.floor(idx / 3);
                const col = idx % 3;
                return {
                    x: col * (cellSize + gap) + cellSize / 2,
                    y: row * (cellSize + gap) + cellSize / 2
                };
            };

            const fromPos = getPosition(fromIndex);
            const toPos = getPosition(toIndex);

            // Determine control points for the Bezier curve
            const deltaX = toPos.x - fromPos.x;
            const deltaY = toPos.y - fromPos.y;
            const dist = Math.hypot(deltaX, deltaY);
            const curvature = 0.3; // Adjust for more or less curvature

            const controlPointOffsetX = -deltaY * curvature;
            const controlPointOffsetY = deltaX * curvature;

            const controlX1 = fromPos.x + controlPointOffsetX;
            const controlY1 = fromPos.y + controlPointOffsetY;
            const controlX2 = toPos.x + controlPointOffsetX;
            const controlY2 = toPos.y + controlPointOffsetY;

            // Create SVG path
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', `M ${fromPos.x} ${fromPos.y} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${toPos.x} ${toPos.y}`);
            path.classList.add('entanglement-line');

            // Set color based on player
            if (player === PLAYER_X) {
                path.style.stroke = '#e63946'; // Red for X
            } else if (player === PLAYER_O) {
                path.style.stroke = '#1d3557'; // Blue for O
            }
            path.style.stroke = '#fedd56';

            entanglementsSVG.appendChild(path);
        }

        // Check Win Condition
        function checkWin() {
            const winPatterns = [
                [0,1,2],
                [3,4,5],
                [6,7,8],
                [0,3,6],
                [1,4,7],
                [2,5,8],
                [0,4,8],
                [2,4,6]
            ];
            for (let pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a].state === 'classical' && board[b].state === 'classical' && board[c].state === 'classical') {
                    if (board[a].value === board[b].value && board[b].value === board[c].value && board[a].value !== EMPTY) {
                        return board[a].value;
                    }
                }
            }
            // Check for draw
            if (board.every(cell => cell.state === 'classical')) {
                return 'Draw';
            }
            return null;
        }

        // Handle Classical Move
        function handleClassicalMove(index) {
            cells.forEach(cell => cell.removeEventListener('click', selectControl));
            cells.forEach(cell => cell.removeEventListener('click', selectTarget));
            unhighlightAll();

            message = 'Select a box to perform Classical Move.';
            render();

            addedEventListener = 0;
            cells.forEach(cell => cell.addEventListener('click', selectClassical));
        }

        function selectClassical(event) {
            const index = parseInt(event.target.getAttribute('data-index'));
            console.log(index);
            performMove(index);
            // Remove this event listener after selection
            cells.forEach(cell => cell.removeEventListener('click', selectClassical));
            addedEventListener = null;
            console.log("classical listener removed");
        }

        function performMove(index) {
            const cellData = board[index];
            cell = cells[index];
            if (cellData.state !== 'quantum') {
                message = 'Classical move can only be applied to a quantum state box.';
                render();
                return;
            }
            // Collapse the quantum state
            const collapse = Math.random() < 0.5 ? Q_ZERO : Q_ONE;
            cellData.state = 'classical';
            if (collapse === Q_ZERO) {
                cellData.value = PLAYER_O;
            } else {
                cellData.value = PLAYER_X;
            }

            // Remove 'quantum' class to stop animation
            cell.classList.remove('quantum');

            // Adding fade-in animation by re-rendering
            render();

            // Handle entanglements
            let measuredEntangled = false;
            board.forEach((c, idx) => {
                if (c.entangledWith === index && c.state === 'classical') {
                    const favoredState = (currentPlayer === PLAYER_X) ? Q_ONE : Q_ZERO;
                    if ((currentPlayer === PLAYER_X && collapse === Q_ONE) ||
                        (currentPlayer === PLAYER_O && collapse === Q_ZERO)) {
                        // Reverse the state
                        c.value = (c.value === PLAYER_X) ? PLAYER_O : PLAYER_X;
                        message = "You measured an entangled particle. And it is in your favor. REVERSAL!"
                        // Add highlight animation
                        const targetCell = cells[idx];
                        targetCell.classList.add('highlight');
                        setTimeout(() => {
                            targetCell.classList.remove('highlight');
                        }, 500);
                    } else {
                        message = "Oh no, you measured an entangled particle but it isn't in your favor. No reversal :("
                    }
                    c.entangledWith = null;
                    measuredEntangled = true;
                }
            });
            if (!measuredEntangled) {
                message = "You measured a quantum particle in a superposition state. It has now collapsed into a classical state."
            }

            // Check for win
            const winner = checkWin();
            if (winner) {
                if (winner === 'Draw') {
                    message = 'The game is a draw!';
                } else {
                    message = `Player ${winner} wins!`;
                }
                render();
                disableMoves();
                return;
            }

            // Switch player
            currentPlayer = (currentPlayer === PLAYER_X) ? PLAYER_O : PLAYER_X;
            // message = '';
            render();
        }

        // Handle Quantum Move
        function handleQuantumMove() {
            unhighlightAll();
            cells.forEach(cell => cell.removeEventListener('click', selectClassical));
            // Quantum move involves selecting a control and a target box
            message = 'Select Control Box for Quantum Move.';
            render();

            let controlBox = null;
            let targetBox = null;

            cells.forEach(cell => cell.addEventListener('click', selectControl));
        }

        function selectControl(event) {
            const index = parseInt(event.target.getAttribute('data-index'));
            const cell = board[index];
            if (cell.state !== 'quantum') {
                message = 'Control box must be in a quantum state.';
                render();
                return;
            }
            controlBox = index;
            message = 'Select Target Box for Quantum Move.';
            render();
            highlightCell(index, 'control');
            // Remove event listener for control selection
            cells.forEach(cell => cell.removeEventListener('click', selectControl));
            // Add event listener for target selection
            cells.forEach(cell => cell.addEventListener('click', selectTarget));
        }

        function selectTarget(event) {
            const index = parseInt(event.target.getAttribute('data-index'));
            const cell = board[index];
            if (cell.state !== 'classical') {
                message = 'Target box must be in a classical state.';
                render();
                return;
            }
            if (index === controlBox) {
                message = 'Control and target boxes must be different.';
                render();
                return;
            }
            targetBox = index;
            // Create entanglement
            board[targetBox].entangledWith = controlBox;
            message = `You successfully entangled box ${controlBox +1} with box ${targetBox +1}. Beware of your (and your opponents') actions now.`;
            // Animate the entanglement creation
            // Yields the entanglement lines through render()
            // Remove event listener for target selection
            cells.forEach(cell => cell.removeEventListener('click', selectTarget));
            // Remove highlight
            unhighlightAll();
            // Switch player
            currentPlayer = (currentPlayer === PLAYER_X) ? PLAYER_O : PLAYER_X;
            render();
        }

        // Highlight selected cell
        function highlightCell(index, type) {
            const cell = cells[index];
            if (type === 'control') {
                cell.style.boxShadow = '0 0 15px 5px #ffdd57';
            } else if (type === 'target') {
                cell.style.boxShadow = '0 0 15px 5px #57ffdd';
            }
        }

        // Remove all highlights
        function unhighlightAll() {
            cells.forEach(cell => {
                cell.style.boxShadow = 'none';
            });
        }

        // Disable further moves after game ends
        function disableMoves() {
            classicalButton.disabled = true;
            quantumButton.disabled = true;
            cells.forEach(cell => cell.style.pointerEvents = 'none');
        }

        // Reset Game
        function resetGame() {
            board = Array(9).fill(EMPTY).map(() => ({
                state: 'quantum',
                value: EMPTY,
                entangledWith: null
            }));
            currentPlayer = PLAYER_X;
            message = "Welcome to the game!";
            classicalButton.disabled = false;
            quantumButton.disabled = false;
            cells.forEach(cell => {
                cell.style.pointerEvents = 'auto';
                cell.style.boxShadow = 'none';
                cell.classList.remove('X', 'O', 'highlight', 'quantum');
                cell.classList.add('quantum'); // Re-add quantum animation
                cell.removeEventListener('click', selectClassical);
                cell.removeEventListener('click', selectControl);
                cell.removeEventListener('click', selectTarget);
            });
            entanglementsSVG.innerHTML = `
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="3.5" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            `;
            render();
        }

        // Attach Event Listeners
        classicalButton.addEventListener('click', () => {
            selectedMove = 'classical';
            handleClassicalMove();
        });

        quantumButton.addEventListener('click', () => {
            selectedMove = 'quantum';
            handleQuantumMove();
        });

        resetButton.addEventListener('click', resetGame);

        // Rules Modal Event Listeners
        rulesButton.onclick = function() {
            rulesModal.style.display = "flex";
        }

        span.onclick = function() {
            rulesModal.style.display = "none";
        }

        initialMusicButton.addEventListener('click', () => {
            backgroundMusic.play();
            soundModal.style.display = 'none';
            musicToggle.style.display = 'block';
        });

        musicToggle.addEventListener('click', () => {
            if (backgroundMusic.paused) {
                backgroundMusic.play();
                playIcon.style.display = 'none';
                pauseIcon.style.display = 'block';
            } else {
                backgroundMusic.pause();
                playIcon.style.display = 'block';
                pauseIcon.style.display = 'none';
            }
        });


        window.onclick = function(event) {
            if (event.target == rulesModal) {
                rulesModal.style.display = "none";
            }
        }

        // Initial Render
        message = "Welcome to the game!"
        render();
        
    </script>
</body>
</html>